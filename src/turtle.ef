!!>
 
 -----------------------------------------------------------------------------
  turtle.f90
  - Basic draw library.
  - Set integer FILE_FOR_TURTLE. The output text data will be written on it.
  - You can draw points, lines (curves), contours, and vector arrows
    in 2-d cartesian and polar coordinates.
  - The outuput is text data of (x,y) positions. It is supposed that
    you use gnuplot, for example, to get the figure output from
    this text data file. See 'turtle.gp' for an example script
    for gnuplot.
 -----------------------------------------------------------------------------
  turtle.f90 by Akira Kageyama, kage@jamstec.go.jp
                Earth Simulator Center, JAMSTEC

    2005.11.22: Start development. Most part of contour comes from my old glib.
    2005.11.24: Minor change in vector_polar.
    2005.11.23: Finished. Beautiful!
    2005.11.24: Added select_file_for_lines and _points.

  Revise by Akira Kageyama (kage@port.kobe-u.ac.jp)

    2015.09.14: Added ALMOST_ZERO and zero check of vector norm max.
    2015.11.18: Incorporating to YYZ code, for in-situ vis. Added verbose mode.
    2015.11.27: Added turtle__rectangle_broken.

  turtle.f03 by Akira Kageyama
 
    2016.09.28: This is turtle.f03.
    2016.09.28: Copied from yyz_relax project. This was turtle.f90
    2016.09.28: Removed "use ut", and changed ut__message to print *.
    2016.09.28: Removed "use namelist", and changed ut__message to print *.
    2016.09.28: Removed "use constants".
    2016.09.29: Use Fortran2003 features, such as associate.
    2016.09.29: Combined various variables into scalar & vector types.
    2016.10.01: Added a new type "window_t".
    2016.10.01: Revised rectangle_structure.

  turtle.ef by Akira Kageyama
    2022.07.11: Minor edit to the eFortran style. This was turtle.e03
    2022.0
!!<

module turtle_m
  use turtle_epsl_m
  implicit none
  private
  public :: & !<< routines >>!
            turtle__arrow,                  &
            turtle__broken_line,            &
            turtle__circle,                 &
            turtle__close,                  &
            turtle__contour_cartesian,      &
            turtle__contour_polar,          &
            turtle__distance,               &
            turtle__eps_footer,             &
            turtle__eps_header,             &
            turtle__initialize,             &
            turtle__line,                   &
            turtle__move,                   &
            turtle__open,                   &
!           turtle__point,                  &
            turtle__present_color_get_val,  &
            turtle__rectangle,              &
            turtle__rectangle_broken,       &
            turtle__set_color,              &
            turtle__string,                 &
            turtle__string_bottom,          &
            turtle__string_top,             &
            turtle__vector_cartesian,       &
            turtle__vector_polar

  public :: & !<< variables >>!
            TURTLE__BLACK, &
            TURTLE__RED,   &
            TURTLE__GREEN, &
            TURTLE__BLUE,  &
            TURTLE__PURPLE

  real <const> :: PI = atan(1.0)*4
  real <const> :: TWOPI = PI*2

  logical, save :: Initialization_done = .false.

  integer <const> :: TURTLE__BLACK  = 0
  integer <const> :: TURTLE__RED    = 1
  integer <const> :: TURTLE__GREEN  = 2
  integer <const> :: TURTLE__BLUE   = 3
  integer <const> :: TURTLE__PURPLE = 4

  integer :: Present_color = TURTLE__BLACK

  integer <const> :: TAG_STRLEN_MAX = 20

  type, public :: turtle__scalar2d_cartesian_t
    integer :: nx, ny
    real :: contour_upper, contour_lower
    integer :: contour_levels
    real, dimension(:) ,  allocatable :: xpos, ypos
    real, dimension(:,:), allocatable :: f
    char(len=TAG_STRLEN_MAX) :: tag ! e.g., "xyplane_rho"
  end type turtle__scalar2d_cartesian_t

  type, public :: turtle__scalar2d_polar_t
    integer :: nr, nt
    real :: contour_upper, contour_lower
    integer :: contour_levels
    real, dimension(:),   allocatable :: rpos
    real, dimension(:),   allocatable :: tpos
    real, dimension(:,:), allocatable :: f
    char(len=TAG_STRLEN_MAX) :: tag
  end type turtle__scalar2d_polar_t

  type, public :: turtle__vector2d_cartesian_t
    integer :: nx, ny
    integer :: stride_for_arrow = 1
    real :: arrow_normalization_unit
    real, dimension(:),   allocatable :: xpos, ypos
    real, dimension(:,:), allocatable :: x, y
    char(len=TAG_STRLEN_MAX) :: tag
  end type turtle__vector2d_cartesian_t

  type, public :: turtle__vector2d_polar_t
    integer :: nr, nt
    real :: vmax
    integer :: stride_for_arrow = 1
    real :: arrow_normalization_unit
    real, dimension(:),   allocatable :: rpos, tpos
    real, dimension(:,:), allocatable :: x, y
    char(len=TAG_STRLEN_MAX) :: tag
  end type turtle__vector2d_polar_t

  type, public :: turtle__pos_t
    real :: x, y
  end type turtle__pos_t

  type, public :: turtle__rectangle_t
    type(turtle__pos_t) :: nw  ! north west
    type(turtle__pos_t) :: ne  ! north east
    type(turtle__pos_t) :: se  ! south east
    type(turtle__pos_t) :: sw  ! south west
  end type turtle__rectangle_t

  type, public :: turtle__common_t
    integer :: file_unit
    integer :: step
    real :: t
    type(turtle__rectangle_t) :: simreg
    real :: magfactor_pixel_per_unit_length
  end type turtle__common_t

  interface operator (*)
     module procedure operator_real_times_typepos
  end interface

  interface operator (/)
     module procedure operator_typepos_div_real
  end interface

  interface operator (+)
     module procedure operator_typepos_plus
  end interface

  interface operator (-)
     module procedure operator_typepos_minus
  end interface

  interface turtle__arrow
     module procedure arrow_structure
  end interface

  interface turtle__broken_line
     module procedure broken_line,              &
                      broken_line_structure
  end interface

  interface turtle__circle
     module procedure circle,                   &
                      circle_structure
  end interface

  interface turtle__distance
     module procedure distance,                 &
                      distance_structure
  end interface

  interface turtle__line
     module procedure line,                     &
                      line_structure
  end interface

! interface turtle__point
!    module procedure point,                    &
!                     point_structure
! end interface

  interface turtle__move
     module procedure move,                     &
                      move_other_coords,        &
                      move_structure
  end interface

  interface turtle__rectangle
     module procedure rectangle,                &
                      rectangle_structure
  end interface

  interface turtle__rectangle_broken
     module procedure rectangle_broken,         &
                      rectangle_structure_broken
  end interface

  !!>
     All coordinates are specified in physical unit, i.e.,
     with the dimension: For example, x=3(m) corresponds
     to x'=3*Magfactor points in the PostScript.
     To avoid negative point position, we first
     translate the origin of the PostScript file.
    
       (0,H) in points     (W,H)
         +-------------------+
         |                   |
         |                   |
         |    PostScript     |
         |                   |
         |                   |
         +-------------------+
       (0,0)               (W,0)  in points
    
       margin                              margin
         /\                                  /\
        /  \                                /  \
       +----.----|-------------------------.----+ <------+
       |    .    |      top message        .    | margin |
       |    +----|-------------------------+    | <------+
       |    |    | \                       |    |
       |    |    |  y=ymax                 |    |
       |    |    |           View rectangle====>|
       |    |    |                         |    |
       |    |    |      Draw rectangle====>|    |
       |    |    |                         |    |
       | x=xmin  |(0,0)                    |    |
      -----------+--------------------------------
       |    |    |                       / |    |
       |    |    |  y=ymin          x=xmax |    |
       |    |    | /                       |    |
       |    +----|-------------------------+    | <------+
       |         |   bottom message             | margin |
       +---------|------------------------------+ <------+

     - A figure is composed of
        (1) header message
        (2) footer message
        (3) visualization picture
     - These are placed in "View rectangle"
     - Their positions, including the two messages,
       are specified by simulation's unit with
       physical dimension, rather than pixels.
     - So, speficy the position and the size of
       the View rectangle in the simulation space.
     - Visualized images of the simulation data
       are drawn in the "Draw window".
  !!<

  type window_t
    type(turtle__rectangle_t) :: view, draw
    real :: draw_diag_length
    real :: margin
  end type window_t

  type(window_t) :: Window

  real <const> :: ALMOST_ZERO = 1.e-12

  logical :: Verbose = .false.

contains

  subroutine arrow_structure( center, vec )
    type(turtle__pos_t) <in> :: center
    type(turtle__pos_t) <in> :: vec
    !!>
                             p
                              \
                               \
                                \
            stt -------------q---- end
                                /
                               /
                              /
                             r
    !!<                             
    real <const> :: ALPHA = 3.0 /  4.0
    real <const> :: BETA  = 1.0 / 12.0
    type(turtle__pos_t) :: stt, end, p, q, r
    if ( (vec.x)**2+(vec.y)**2 < 1.e-4 ) then   ! too short
      return
    end if
    stt = center - (0.5*vec)
    end = center + (0.5*vec)
    q = stt + (ALPHA*vec)
    p.x = q.x + BETA*(vec.y)
    p.y = q.y - BETA*(vec.x)
    r.x = q.x - BETA*(vec.y)
    r.y = q.y + BETA*(vec.x)
    call turtle__move(stt)
    call turtle__line(end)
    call turtle__move(p)
    call turtle__line(end)
    call turtle__line(r)
  end subroutine arrow_structure


  subroutine broken_line( x, y, new )
    real <in> :: x, y
    logical <optin> :: new
    type(turtle__pos_t) :: pos
    pos.x = x
    pos.y = y
    if ( present( new ) ) then
       call broken_line_structure( pos, new )
    else
       call broken_line_structure( pos )
    end if
  end subroutine broken_line


  subroutine broken_line_structure( pos_in, new )
    type(turtle__pos_t) <in> :: pos_in
    logical <optin> :: new
!     Original code developed by A. Kageyama in early 1990s in f77.
!     1994.06.07: modified
!     2005.11.23: re-written in f90 by A. Kageyama.
    real <const> :: UNIT1_FACTOR = 0.01
    real <const> :: UNIT2_FACTOR = 0.0025
    real, save :: amari = 0.0  ! i know it's automatic save.
    type(turtle__pos_t) :: pos, pos0, pos1, vnormd
    real :: dist, rmaind
    integer :: i

    real :: unit1, unit2, unit
    type(turtle__pos_t), save :: pos_prev

    if ( Verbose .and. (Window.draw_diag_length < 1.e-5) ) then
       print *,'<__FUNC__> Window.draw_diag_length = 0? Do nothing.'
       return
    endif
    unit1 = UNIT1_FACTOR*Window.draw_diag_length
    unit2 = UNIT2_FACTOR*Window.draw_diag_length
    unit  = unit1 + unit2
    if ( present( new ) ) then
       pos_prev = pos_in
       amari = 0.0
       return
    end if
    pos0 = pos_prev
    pos  = pos_in

    dist = turtle__distance(pos0,pos)
    if( dist < 1.e-5 ) return
    vnormd = (pos-pos0)/dist
!!>    
   (gx0,gy0)                                         (gx,gy)
       !                                                !
       !<-------------------d-i-s-t-------------------->!
       !-----!-----------------!-----------------!------!---------!
       !amari!      unit       !       unit      !rmaind!  amari  !
       !                                                !
             !--unit1--!-unit2-!
             !<-----unit------>!
!!<
    if( amari > dist ) then
      if( amari < unit2 ) then
        call turtle__move( pos )
      else if( amari-unit2 < dist ) then
        pos1 = pos0 + (amari-unit2)*vnormd
        call turtle__line( pos1 )
        call turtle__move( pos )
      else
        call turtle__line( pos )
      end if
      amari = amari - dist
      pos_prev = pos_in
      return
    end if
    if( amari > unit2 ) then
      pos1 = pos0 + (amari-unit2)*vnormd
      pos0 = pos0 + amari*vnormd
      call turtle__line( pos1 )
      call turtle__move( pos0 )
    else
      pos0 = pos0 + amari*vnormd
      call turtle__move(pos0)
    end if
    do i = 1 , int( (dist-amari)/unit )
      pos1 = pos0 + unit1*vnormd
      pos0 = pos0 +  unit*vnormd
      call turtle__line( pos1 )
      call turtle__move( pos0 )
    end do
    rmaind = mod( dist-amari, unit )
    if( rmaind > unit1 ) then
      pos1 = pos0 + unit1*vnormd
      call turtle__line( pos1 )
      call turtle__move( pos )
    else
      call turtle__line( pos )
    end if
    amari = unit - rmaind
    pos_prev = pos_in
  end subroutine broken_line_structure


  subroutine check_and_draw_cartesian( i, j, iside, ifound, karte, lineid, &
                                       field, val, flag_x, flag_y )
    integer <in> :: i, j, iside
    integer <io> :: ifound, karte
    char(len=5) <in> :: lineid
    type(turtle__scalar2d_cartesian_t) <in> :: field
    real <in> :: val
    integer, dimension(:,:) <io> :: flag_x, flag_y
    !!>
        purpose : check and draw a contour line segment
                  in cartesian corrdinate.
        note    :
        called  : lnfolw_cartesian
   
        originally developed by Akira Kageyama in early 1990s in f77.
        2005.11.23: Converted into f90 by Akira Kageyama.
        2016.09.30: Made flag_x and _y being arguments. by kage.
    !!<
    real :: xxx, yyy

    if ( iside==1 .or. iside==4 ) then
      if ( (field.f(i,j)-val)*(field.f(i+1,j)-val) <= 0. ) then
        ! you've found a line.
        ifound = 1
        if ( field.f(i,j) == field.f(i+1,j) ) then
          xxx = ( field.xpos(i)+field.xpos(i+1) ) / 2.
        else
          xxx = field.xpos(i)  &
              - (field.f(i,j)-val)*(field.xpos(i+1)-field.xpos(i))  &
                            /(field.f(i+1,j)-field.f(i,j))
        end if
        yyy = field.ypos(j)
        if ( lineid=='solid' ) then
          call turtle__line( xxx, yyy )
        else if ( lineid=='brokn' ) then
          call turtle__broken_line( xxx, yyy )
        end if
        if ( iside==1 .and. j==field.ny )   karte = 9
        if ( iside==4 .and. j==1  )         karte = 9
        !  line closing check
        if ( flag_x(i,j)==1 ) karte = 8
      end if
      flag_x( i, j ) = 1
    else if ( iside==2 .or. iside==3 ) then
      if ( (field.f(i,j)-val)*(field.f(i,j+1)-val) <= 0. ) then
        !  you've found a line.
        ifound = 1
        if ( field.f(i,j)==field.f(i,j+1) ) then
          yyy = ( field.ypos(j)+field.ypos(j+1) ) / 2.
        else
          yyy = field.ypos(j)  &
              - (field.f(i,j)-val)*(field.ypos(j+1)-field.ypos(j))  &
                                  /(field.f(i,j+1)-field.f(i,j))
        end if
        xxx = field.xpos(i)
        if( lineid=='solid' ) then
          call turtle__line( xxx, yyy )
        else if ( lineid=='brokn' ) then
          call turtle__broken_line( xxx, yyy )
        end if
        !   regeion check
        if ( iside==2 .and. i==field.nx )   karte = 9
        if ( iside==3 .and. i==1  )         karte = 9
        !  line closing check
        if ( flag_y(i,j)==1 )  karte = 8
      end if
      flag_y(i,j) = 1
    end if
  end subroutine check_and_draw_cartesian


  subroutine check_and_draw_polar( i, j, iside, ifound, karte, lineid,  &
                                   field, val, flag_r, flag_t )
    integer <in> :: i, j, iside
    integer <io> :: ifound, karte
    char(len=5) <in> :: lineid
    type(turtle__scalar2d_polar_t) <in> :: field
    real <in> :: val
    integer, dimension(:,:) <io> :: flag_r, flag_t
    !!>
       purpose : check and draw a contour line segment
                 in the polar-corrdinates.
       note    :
       called  : lnfolw_polar
  
       originally developed by Akira Kageyama in early 1990s in f77.
       2005.11.24: Converted into f90 by Akira Kageyama.
    !!<
    real :: rad, tht
    type(turtle__pos_t) :: pos

    if ( iside==1 .or. iside==4 ) then
      if ( (field.f(i,j)-val)*(field.f(i+1,j)-val) <= 0. ) then
        ! you've found a line.
        ifound = 1
        if ( field.f(i,j) == field.f(i+1,j) ) then
           rad = ( field.rpos(i)+field.rpos(i+1) ) / 2.
        else
           rad = field.rpos(i)                                       &
               - (field.f(i,j)-val)*(field.rpos(i+1)-field.rpos(i))        &
                             /(field.f(i+1,j)-field.f(i,j))
        end if
        tht = field.tpos(j)
        pos = coords_trans_polar_to_cartesian( rad, tht )
        if ( lineid=='solid' ) then
           call turtle__line( pos )
        else if ( lineid=='brokn' ) then
           call turtle__broken_line( pos )
        end if
        if ( iside==1 .and. j==field.nt )   karte = 9
        if ( iside==4 .and. j==1  )         karte = 9
        !  line closing check
        if ( flag_r(i,j)==1 ) karte = 8
      end if
      flag_r(i,j) = 1
    else if ( iside==2 .or. iside==3 ) then
      if ( (field.f(i,j)-val)*(field.f(i,j+1)-val) <= 0. ) then
        !  you've found a line.
        ifound = 1
        if ( field.f(i,j)==field.f(i,j+1) ) then
           tht = ( field.tpos(j)+field.tpos(j+1) ) / 2.
        else
           tht = field.tpos(j)                                       &
               - (field.f(i,j)-val)*(field.tpos(j+1)-field.tpos(j))  &
                             /(field.f(i,j+1)-field.f(i,j))
        end if
        rad = field.rpos(i)
        pos = coords_trans_polar_to_cartesian( rad, tht )
        if( lineid=='solid' ) then
           call turtle__line( pos )
        else if ( lineid=='brokn' ) then
            call turtle__broken_line( pos )
        end if
        !   regeion check
        if ( iside==2 .and. i==field.nr )   karte = 9
        if ( iside==3 .and. i==1  )         karte = 9
        !  line closing check
        if ( flag_t(i,j)==1 )  karte = 8
      end if
      flag_t(i,j) = 1
    end if
  end subroutine check_and_draw_polar

  subroutine circle( center_x, center_y, radius, angle_from,angle_to )
    real <in> :: center_x, center_y, radius
    real <optin> :: angle_from, angle_to
    !!>
        revised to use DTHT, for cases when the span angle is very narrow.
        by kage on 15.11.18 for yyz_thin at Kobe U.
    !!<
    real :: x, y, tht
    integer  :: ndiv
    real :: tht_from, tht_to
    real <const> :: DTHT = PI / 180  ! = 1 degree

    if ( present( angle_from ) .and. present( angle_to ) ) then
       tht_from = angle_from
       tht_to   = angle_to
    else
       tht_from = 0.0
       tht_to   = TWOPI
    end if

    ndiv = ( tht_to - tht_from ) / DTHT    ! round down.

    call iBegin
    call iArc
    call iEnd

  contains

    subroutine iArc
      integer :: i
      do i = 1 , ndiv
         tht = tht_from + DTHT*i
         x = center_x + radius*cos( tht )
         y = center_y + radius*sin( tht )
         call line( x, y )
      end do
    end subroutine iArc

    subroutine iBegin
      x = center_x + radius*cos( tht_from )
      y = center_y + radius*sin( tht_from )
      call move( x, y )
    end subroutine iBegin

    subroutine iEnd
      x = center_x + radius*cos( tht_to )
      y = center_y + radius*sin( tht_to )
      call line( x, y )
    end subroutine iEnd

  end subroutine circle


  subroutine circle_structure( center, radius, tht_from, tht_to )
    type(turtle__pos_t) <in> :: center
    real <in> :: radius
    real <optin> :: tht_from, tht_to

    if ( present( tht_from ) .and. present( tht_to ) ) then
       call circle( center.x, center.y, radius, tht_from, tht_to )
    else
       call circle( center.x, center.y, radius)
    end if
  end subroutine circle_structure


  subroutine cont0_cartesian( field, val, lineid, flag_x, flag_y )
    type(turtle__scalar2d_cartesian_t) <in> :: field
    real <in> :: val
    char(len=5) <in> :: lineid
    integer, dimension(:,:) <io> :: flag_x, flag_y
      !!>
         purpose : draw a contour line of height 0 in cartesian coordinate.
         note    :
         calls   : lnfolw_cartesian, cplot
         called  : contr
         by a. kageyama    91.06.18
    
         2005.11.23: Converted into f90 by Akira Kageyama.
         2016.09.30: Made flag_x and _y being arguments. by kage.
      !!<
    integer  :: nx, ny, i, j
    real :: xxx, yyy
    integer  :: ienter, inow, jnow, karte

    nx = field.nx
    ny = field.ny

    flag_x(:,:) = 0  ! reset
    flag_y(:,:) = 0

    do  i = 1 , nx
       do  j = 1 , ny - 1
          if ( flag_y(i,j)==1 ) cycle
          !  unexplored segment.
          flag_y(i,j) = 1

          if ( (field.f(i,j)-val)*(field.f(i,j+1)-val)<=0. ) then
             ! you've found a line.
             if ( field.f(i,j)==field.f(i,j+1) ) then
                ! same val on the both points.
                yyy = ( field.ypos(j)+field.ypos(j+1) ) / 2.
             else
                yyy = field.ypos(j)  &
                     - (field.f(i,j)-val)*(field.ypos(j+1)-field.ypos(j))  &
                     /(field.f(i,j+1)-field.f(i,j))
             end if
             xxx = field.xpos(i)

             call turtle__move( xxx, yyy )
             if ( lineid=='brokn' ) call turtle__broken_line( xxx, yyy, new=.true. )

             if ( i/=nx ) then
                !    2-direction
                ienter = 2
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_cartesian( inow, jnow, ienter, karte, lineid,  &
                                          field, val, flag_x, flag_y )
                end do
             end if

             call turtle__move( xxx, yyy )
             if ( lineid=='brokn' ) call turtle__broken_line( xxx, yyy, new=.true. )

             if ( i/=1 ) then
                !    3-direction
                ienter = 3
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_cartesian( inow, jnow, ienter, karte, lineid,  &
                                          field, val, flag_x, flag_y )
                end do
             end if
          end if
       end do
    end do

    do j = 1 , ny
       do i = 1 , nx-1
          if ( flag_x(i,j)==1 ) cycle
          !   unexplored segment.
          flag_x(i,j) = 1

          if ( (field.f(i,j)-val)*(field.f(i+1,j)-val)<=0. ) then
             ! you've found a line.
             if ( field.f(i,j)==field.f(i+1,j) ) then
                !    0 on both points.
                xxx = ( field.xpos(i)+field.xpos(i+1) ) / 2.
             else
                xxx = field.xpos(i)                                    &
                     - (field.f(i,j)-val)*(field.xpos(i+1)-field.xpos(i))    &
                                   /(field.f(i+1,j)-field.f(i,j))
             end if
             yyy = field.ypos(j)
             call turtle__move( xxx, yyy )
             if ( lineid=='brokn' ) call turtle__broken_line( xxx, yyy, new=.true. )

             if ( j/=ny ) then
                ienter = 1
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_cartesian( inow, jnow, ienter, karte, lineid,  &
                                          field, val, flag_x, flag_y )
                end do
             end if

             call turtle__move( xxx, yyy )
             if ( lineid=='brokn' ) call turtle__broken_line( xxx, yyy, new=.true. )

             if( j/=1 ) then
                ienter = 4
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_cartesian( inow, jnow, ienter, karte, lineid,  &
                                          field, val, flag_x, flag_y)
                end do
             end if
          end if
       end do
    end do

  end subroutine cont0_cartesian


  subroutine cont0_polar( field, val, lineid, flag_r, flag_t )
    type(turtle__scalar2d_polar_t) <in> :: field
    real <in> :: val
    char(len=5) <in> :: lineid
    integer, dimension(:,:) <io> :: flag_r, flag_t
    !!>
        purpose : draw a contour line of height 0 in the polar-coords.
        note    :
        calls   : lnfolw_polar, cplot
        called  : contr
   
        by a. kageyama    91.06.18
   
        2005.11.24: Converted into f90 by Akira Kageyama.
    !!<
    integer :: nr, nt, i, j
    real    :: rad, tht
    integer :: ienter, inow, jnow, karte

    type(turtle__pos_t) :: pos

    nr = field.nr
    nt = field.nt

    call iFlag_reset

    do  i = 1 , nr
       do  j = 1 , nt - 1
          if ( flag_t(i,j)==1 ) cycle
          !  unexplored segment.
          flag_t(i,j) = 1

          if ( (field.f(i,j)-val)*(field.f(i,j+1)-val)<=0. ) then
             ! you've found a line.
             if ( field.f(i,j)==field.f(i,j+1) ) then
                ! same val on the both points.
                tht = ( field.tpos(j)+field.tpos(j+1) ) / 2.
             else
                tht = field.tpos(j)                                  &
                     - (field.f(i,j)-val)*(field.tpos(j+1)-field.tpos(j))  &
                                   /(field.f(i,j+1)-field.f(i,j))
             end if
             rad = field.rpos(i)

             pos = coords_trans_polar_to_cartesian( rad, tht )
             call turtle__move( pos )
             if ( lineid=='brokn' ) call turtle__broken_line( pos, new=.true. )

             if ( i/=nr ) then
                !    2-direction
                ienter = 2
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_polar( inow, jnow, ienter, karte, lineid,  &
                                      field, val, flag_r, flag_t )
                end do
             end if

             call turtle__move( pos )
             if ( lineid=='brokn' ) call turtle__broken_line( pos, new=.true. )

             if ( i/=1 ) then
                !    3-direction
                ienter = 3
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_polar( inow, jnow, ienter, karte, lineid,  &
                                      field, val, flag_r, flag_t )
                end do
             end if
          end if
       end do
    end do

    do j = 1 , nt
       do i = 1 , nr-1
          if ( flag_r(i,j)==1 ) cycle
          !   unexplored segment.
          flag_r(i,j) = 1

          if ( (field.f(i,j)-val)*(field.f(i+1,j)-val)<=0. ) then
             ! you've found a line.
             if ( field.f(i,j)==field.f(i+1,j) ) then
                !    0 on both points.
                rad = ( field.rpos(i)+field.rpos(i+1) ) / 2.
             else
                rad = field.rpos(i)                                    &
                     - (field.f(i,j)-val)*(field.rpos(i+1)-field.rpos(i))    &
                                   /(field.f(i+1,j)-field.f(i,j))
             end if
             tht = field.tpos(j)

             pos = coords_trans_polar_to_cartesian( rad, tht )

             call turtle__move( pos )
             if ( lineid=='brokn' ) call turtle__broken_line( pos, new=.true. )

             if ( j/=nt ) then
                ienter = 1
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_polar( inow, jnow, ienter, karte, lineid,  &
                                      field, val, flag_r, flag_t )
                end do
             end if

             call turtle__move( pos )
             if (lineid=='brokn') call turtle__broken_line( pos, new=.true. )

             if( j/=1 ) then
                ienter = 4
                inow = i
                jnow = j
                karte = 0
                do while ( karte==0 )
                   call lnfolw_polar( inow, jnow, ienter, karte,lineid,  &
                                      field, val, flag_r, flag_t )
                end do
             end if
          end if
       end do
    end do

  contains

    subroutine iFlag_reset
      do  i = 1 , nr
        do  j = 1 , nt
          flag_r(i,j) = 0
          flag_t(i,j) = 0
        end do
      end do
    end subroutine iFlag_reset

  end subroutine cont0_polar



  function coords_trans_polar_to_cartesian( rad, tht )
    real <in> :: rad, tht
    type(turtle__pos_t) :: coords_trans_polar_to_cartesian

    coords_trans_polar_to_cartesian.x = rad*cos( tht )
    coords_trans_polar_to_cartesian.y = rad*sin( tht )
  end function coords_trans_polar_to_cartesian


  function distance( x1, y1, x2, y2 )
    real <in> :: x1, y1, x2, y2
    real :: distance

    type(turtle__pos_t) :: pos1, pos2

    pos1.x = x1
    pos1.y = y1
    pos2.x = x2
    pos2.y = y2

    distance = distance_structure( pos1, pos2 )
  end function distance


  function distance_structure( pos1, pos2 )
    type(turtle__pos_t) <in> :: pos1, pos2
    real :: distance_structure

    distance_structure = sqrt( (pos1.x-pos2.x)**2+(pos1.y-pos2.y)**2 )
  end function distance_structure


  subroutine lnfolw_cartesian( i, j, ienter, karte, lineid, field,val,  &
                               flag_x, flag_y)
    integer <io> :: i, j, ienter
    integer <io> :: karte
    char(len=5) <in> :: lineid
    type(turtle__scalar2d_cartesian_t) <in> :: field
    real <in> :: val
    integer, dimension(:,:) <io> :: flag_x, flag_y
    !!>
        purpose : elemental step for draw a contour line in
                  cartesian coordinanate.
        note    : effectively recursive routine.
        called  : cont0_cartesian
        calls   : check_and_draw_cartesian
   
        originally developed by Akira Kageyama in early 1990s in f77.
        2005.11.23: Converted into f90 by Akira Kageyama.
        2016.09.30: Made flag_x and _y being arguments. by kage.
    !!<
    integer, dimension(4,4), save :: iadd, jadd
    logical :: first = .true.
    integer :: i1, j1, iside, ifound

    if ( first ) then
       call iInit
       first = .false.
    end if

    do iside = 1 , 4
       if( ienter+iside == 5 ) cycle
       i1 = i + iadd( ienter, iside )
       j1 = j + jadd( ienter, iside )
       ifound = 0
       call check_and_draw_cartesian( i1, j1, iside, ifound, karte, lineid, &
                                      field, val, flag_x, flag_y)
       if ( ifound==1 ) then
          i = i1
          j = j1
          ienter = iside
          return
       end if
    end do
    karte = 99

  contains

    subroutine iInit
       iadd(1,1) = 0
       jadd(1,1) = 1
       iadd(1,2) = 1
       jadd(1,2) = 0
       iadd(1,3) = 0
       jadd(1,3) = 0

       iadd(2,1) = 0
       jadd(2,1) = 1
       iadd(2,2) = 1
       jadd(2,2) = 0
       iadd(2,4) = 0
       jadd(2,4) = 0

       iadd(3,1) = -1
       jadd(3,1) = 1
       iadd(3,3) = -1
       jadd(3,3) = 0
       iadd(3,4) = -1
       jadd(3,4) = 0

       iadd(4,2) = 1
       jadd(4,2) = -1
       iadd(4,3) = 0
       jadd(4,3) = -1
       iadd(4,4) = 0
       jadd(4,4) = -1
     end subroutine iInit

   end subroutine lnfolw_cartesian


  subroutine lnfolw_polar( i, j, ienter, karte, lineid, field, val, flag_r, flag_t )
    integer <io> :: i, j, ienter
    integer <io> :: karte
    char(len=5) <in> :: lineid
    type(turtle__scalar2d_polar_t) <in> :: field
    integer, dimension(:,:) <io> :: flag_r, flag_t
    real <in> :: val
    !!>
        purpose : elemental step for draw a contour line in
                  the polar-coordinanates.
        note    : effectively recursive routine.
        called  : cont0_polar
        calls   : check_and_draw_polar
   
        originally developed by Akira Kageyama in early 1990s in f77.
   
        2005.11.24: Converted into f90 by Akira Kageyama.
    !!<
    integer, dimension(4,4), save :: iadd, jadd
    logical :: first = .true.
    integer :: i1, j1, iside, ifound

    if (first) then
      call iInit
      first = .false.
    end if

    do iside = 1 , 4
       if( ienter+iside == 5 ) cycle
       i1 = i + iadd( ienter, iside )
       j1 = j + jadd( ienter, iside )
       ifound = 0
       call check_and_draw_polar( i1, j1, iside, ifound, karte, lineid, &
                                  field, val, flag_r, flag_t)
       if ( ifound==1 ) then
          i = i1
          j = j1
          ienter = iside
          return
       end if
    end do
    karte = 99

  contains

    subroutine iInit
       iadd(1,1) = 0
       jadd(1,1) = 1
       iadd(1,2) = 1
       jadd(1,2) = 0
       iadd(1,3) = 0
       jadd(1,3) = 0

       iadd(2,1) = 0
       jadd(2,1) = 1
       iadd(2,2) = 1
       jadd(2,2) = 0
       iadd(2,4) = 0
       jadd(2,4) = 0

       iadd(3,1) = -1
       jadd(3,1) = 1
       iadd(3,3) = -1
       jadd(3,3) = 0
       iadd(3,4) = -1
       jadd(3,4) = 0

       iadd(4,2) = 1
       jadd(4,2) = -1
       iadd(4,3) = 0
       jadd(4,3) = -1
       iadd(4,4) = 0
       jadd(4,4) = -1
     end subroutine iInit

   end subroutine lnfolw_polar


  subroutine line( xp, yp )
    real <in> :: xp, yp

    if ( Verbose .and. (.not. Initialization_done) ) then
       print *, "<__FUNC__> You forgot initialization. Do nothing."
       return
    end if

    call turtle_epsl__midline( xp, yp )
  end subroutine line


  subroutine line_structure( pos )
    type(turtle__pos_t) <in> :: pos

    call line( pos.x, pos.y )
  end subroutine line_structure


  subroutine move( xp, yp )
    real <in> :: xp, yp

    if ( Verbose .and. (.not. Initialization_done) ) then
       print *, "<__FUNC__> You forgot initialization. Do nothing."
       return
    end if

    call turtle_epsl__newline( xp, yp )
  end subroutine move


  subroutine move_other_coords( rad, tht, coords )
    real <in> :: rad, tht
    char(len=*) <in> :: coords

    real :: x, y

    if ( coords=='polar' ) then
       x = rad*cos( tht )
       y = rad*sin( tht )
       call move( x, y )
    else
       if ( Verbose ) then
         print *, '<__FUNC__>'//                 &
                  ' This coordinate system is not supported:'//  &
                  coords
       end if
    end if
  end subroutine move_other_coords


  subroutine move_structure( pos )
    type(turtle__pos_t) <in> :: pos

    call move( pos.x, pos.y )
  end subroutine move_structure


  function operator_real_times_typepos( realsp, typepos )
    real <in> :: realsp
    type(turtle__pos_t)  <in> :: typepos
    type(turtle__pos_t) :: operator_real_times_typepos

    operator_real_times_typepos.x = realsp*( typepos.x )
    operator_real_times_typepos.y = realsp*( typepos.y )
  end function operator_real_times_typepos


  function operator_typepos_div_real( pos, div )
    type(turtle__pos_t) <in> :: pos
    real <in> :: div
    type(turtle__pos_t) :: operator_typepos_div_real

    operator_typepos_div_real.x = pos.x / div
    operator_typepos_div_real.y = pos.y / div
  end function operator_typepos_div_real


  function operator_typepos_minus( a, b )
    type(turtle__pos_t) <in> :: a, b
    type(turtle__pos_t) :: operator_typepos_minus

    operator_typepos_minus.x = a.x - b.x
    operator_typepos_minus.y = a.y - b.y
  end function operator_typepos_minus


  function operator_typepos_plus( a, b )
    type(turtle__pos_t) <in> :: a, b
    type(turtle__pos_t) :: operator_typepos_plus

    operator_typepos_plus.x = a.x + b.x
    operator_typepos_plus.y = a.y + b.y
  end function operator_typepos_plus


! subroutine point(xp,yp)
!   real <in> :: xp, yp

!   real :: ox, oy

!   if (Verbose .and. (.not. Initialization_done)) then
!      print *, "<turtle/point> You forgot initialization. Do nothing."
!      return
!   end if
!   ox = Draw_area.origin.x
!   oy = Draw_area.origin.y
!   ! In yyz_thin project, this part was not commented out.
!   ! But I guess this should be an another call to epslib function.
!   ! I'll ask this part to Shimizu-kun, before long. I just comment
!   ! out this line for now, because I'll remove (seemingly) unused
!   ! variable FILE_FOR_TURTLE.  16.09.29 (kage).
!   !   write(FILE_FOR_TURTLE,*) ox+xp, oy+yp
!   print *,' <turtle/point> Do nothing... Need help...'
! end subroutine point

! subroutine point_structure(pos)
!   type(turtle__pos_t) <in> :: pos

!   call point(pos.x,pos.y)
! end subroutine point_structure


!  subroutine rectangle_structure(pos_sw,pos_ne)
!    type(turtle__pos_t) <in> :: pos_sw, pos_ne
!!                               pos_ne
!!           +--------------------+
!!           |                    |
!!           |                    |
!!           |                    |
!!           |                    |
!!           |                    |
!!           +--------------------+
!!        pos_sw
!    call rectangle(pos_sw.x,pos_sw.y,pos_ne.x,pos_ne.y)
!  end subroutine rectangle_structure


  subroutine rectangle_structure( rect )
    type(turtle__rectangle_t) <in> :: rect
    call rectangle( rect.sw.x, rect.sw.y, rect.ne.x, rect.ne.y )
  end subroutine rectangle_structure


  subroutine rectangle( xsw, ysw, xne, yne ) ! sw means south-west
    real <in> :: xsw, ysw, xne, yne          ! ne means north-east
    !!>    
                                (xne,yne)
            +--------------------+
            |                    |
            |                    |
            |                    |
            |                    |
            |                    |
            +--------------------+
       (xsw,ysw)
    !!<
    type(turtle__pos_t) :: nw, ne, sw, se

    sw.x = xsw
    sw.y = ysw
    nw.x = xsw
    nw.y = yne
    ne.x = xne
    ne.y = yne
    se.x = xne
    se.y = ysw

    call move_structure( sw )
    call line_structure( nw )
    call line_structure( ne )
    call line_structure( se )
    call line_structure( sw )
  end subroutine rectangle


  subroutine rectangle_structure_broken( pos_sw, pos_ne )
    type(turtle__pos_t) <in> :: pos_sw, pos_ne
    !!>
                                    pos_ne
                +--------------------+
                |                    |
                |                    |
                |                    |
                |                    |
                |                    |
                +--------------------+
             pos_sw
      
    !!<
    call rectangle_broken( pos_sw.x, pos_sw.y, pos_ne.x, pos_ne.y )
  end subroutine rectangle_structure_broken


  subroutine rectangle_broken( xsw, ysw, xne, yne ) ! sw means south-west
    real <in> :: xsw, ysw, xne, yne                 ! ne means north-east

    !!>
          (xsw,yne)                (xne,yne)
               +--------------------+
               |                    |
               |                    |
               |                    |
               |                    |
               |                    |
               +--------------------+
          (xsw,ysw)                (xne,ysw)
    !!<
    call broken_line( xsw, ysw, new=.true. )
    call broken_line( xne, ysw )
    call broken_line( xne, yne )
    call broken_line( xsw, yne )
    call broken_line( xsw, ysw )
  end subroutine rectangle_broken


! private
!=========
! public


  subroutine turtle__contour_cartesian( scalar )
    type(turtle__scalar2d_cartesian_t) <in> :: scalar
    !!>
        purpose : draw a contour line in x-y coordinate.
        calls   : cont0_cartesian
        by a. kageyama    92.03.07 (modified from pcontr)
        ____
   
        2005.11.23: Converted into f90 by Akira Kageyama
        2015.11.18: Revised for in-situ quick drawing.
                    by Akira kageyama, for yyz_thin, on 15.11.18, at Kobe.
    !!<
    integer :: nx, ny, l
    real, dimension(:), allocatable :: level
    integer, dimension(:,:), allocatable :: flag_x, flag_y

    nx = scalar.nx
    ny = scalar.ny

    associate ( nlevel => scalar.contour_levels )
      allocate( level(nlevel), flag_x(nx,ny), flag_y(nx,ny) )
      call iSet_levels( nlevel )

      if( (level(2) .eq. 100000000.) .and. (level(4) .eq. 100000000.) ) then
         deallocate( level, flag_x, flag_y )
         return
      end if

        do l = 1 , nlevel
          if ( level(l) >= 0.0 ) then
            call cont0_cartesian( scalar, level(l), 'solid', flag_x, flag_y )
          else
            call cont0_cartesian( scalar, level(l), 'brokn', flag_x, flag_y )
          end if
        end do
      deallocate( level, flag_x, flag_y )
    end associate

  contains

    subroutine iSet_levels( nlevel )
      integer <in> :: nlevel
      real :: dval, vmax, vmin, vdiff

      vmax = scalar.contour_upper
      vmin = scalar.contour_lower
      if ( vmax <= vmin ) then
        vmax = maxval( scalar.f(:,:) )
        vmin = minval( scalar.f(:,:) )
      end if

      if ( Verbose ) then
        print *, '<__FUNC__>  vmax = ',vmax
        print *, '            vmin = ',vmin
      end if

      vdiff = vmax - vmin
      if ( vdiff <= ALMOST_ZERO ) then
         level(:) = 100000000
         return
      end if
      if ( nlevel <= 0 ) return
      !!>
          vmin                                     vmax
           |   dval dval dval                       |
           |  |----|----|----|                      |
           x--o----o----o----o----o----o----o----o--x
           |  1    2    3    4    5    6    7    8  |
           |  |                                  |  |
            \/                                    \/
           dval/2                                dval/2
      !!<
      dval = vdiff / nlevel
      do l = 1 , nlevel
         level(l) = vmin + 0.5*dval + dval*real(l-1)
      end do
    end subroutine iSet_levels

  end subroutine turtle__contour_cartesian


  subroutine turtle__contour_polar( scalar )
    type(turtle__scalar2d_polar_t) <in> :: scalar
    !!>
        purpose : draw a contour line in the polar-coordinates.
        calls   : cont0_polar
   
        by a. kageyama    92.03.07 (modified from pcontr)
        ____
   
        2005.11.24: Converted into f90 by Akira Kageyama
        2015.11.18: Revised for in-situ quick drawing.
                    by Akira kageyama, for yyz_thin, on 15.11.18, at Kobe.
    !!<
    real, dimension(:), allocatable :: level
    integer :: nr, nt, l
    integer, dimension(:,:), allocatable :: flag_r, flag_t

    nr = scalar.nr
    nt = scalar.nt

    associate ( nlevel => scalar.contour_levels )
      allocate(level(nlevel),flag_r(nr,nt),flag_t(nr,nt))
        call iSet_levels(nlevel)
!       print *,'  in cont_pol: max,min = ',  &
!               maxval(scalar.f(:,:)), minval(scalar.f(:,:))
        do l = 1 , nlevel
           if ( level(l) >= 0.0 ) then
             call cont0_polar( scalar, level(l), 'solid', flag_r, flag_t )
           else
             call cont0_polar( scalar, level(l), 'brokn', flag_r, flag_t )
           end if
        end do
      deallocate( level, flag_r, flag_t )
    end associate

  contains

    subroutine iSet_levels( nlevel )
      integer <in> :: nlevel

      real :: dval, vmax, vmin, vdiff
      if ( scalar.contour_upper <= scalar.contour_lower ) then
        vmax = maxval( scalar.f(:,:) )
        vmin = minval( scalar.f(:,:) )
      end if

      !  if ( Verbose ) then
      !    print *, '<turtle/contour_polar> vmax = ',vmax
      !    print *, '                       vmin = ',vmin
      !  end if

      vdiff = vmax - vmin
      if ( vdiff <= ALMOST_ZERO ) return
      if ( nlevel <= 0 ) return
      !!>
           vmin                                     vmax
            |   dval dval dval                       |
            |  |----|----|----|                      |
            x--o----o----o----o----o----o----o----o--x
            |  1    2    3    4    5    6    7    8  |
            |  |                                  |  |
             \/                                    \/
            dval/2                                dval/2
      !!<
      dval = vdiff / nlevel
      do l = 1 , nlevel
         level(l) = vmin + 0.5*dval + dval*real(l-1)
      end do
    end subroutine iSet_levels

  end subroutine turtle__contour_polar


  subroutine turtle__initialize( com )
    type(turtle__common_t) <in> :: com

    real :: magfactor
    real :: width_in_physical_unit, height_in_physical_unit
    real :: origin_shift_x, origin_shift_y
    real :: font_size_in_physical_unit
    real :: margin
    integer :: line_width_in_pixel
    !!>
            margin
             /  \
            .    .    Two margins are equal.
            .    .
            |    |
            |    |
            |    | Draw window
            |    +--------------. . .-+
            | View window             | margin
            +-------------------. . .-+
        - A figure is composed of
    !!<
    Window.draw = com.simreg

    Window.draw_diag_length = turtle__distance( com.simreg.sw.x,  &
                                                com.simreg.sw.y,  &
                                                com.simreg.ne.x,  &
                                                com.simreg.ne.y )
    margin = Window.draw_diag_length*0.1
    Window.margin = margin
    Window.view.nw.x = Window.draw.nw.x - margin
    Window.view.nw.y = Window.draw.nw.y + margin
    Window.view.ne.x = Window.draw.ne.x + margin
    Window.view.ne.y = Window.draw.ne.y + margin
    Window.view.se.x = Window.draw.se.x + margin
    Window.view.se.y = Window.draw.se.y - margin
    Window.view.sw.x = Window.draw.sw.x - margin
    Window.view.sw.y = Window.draw.sw.y - margin

    width_in_physical_unit  = Window.view.ne.x - Window.view.nw.x
    height_in_physical_unit = Window.view.nw.y - Window.view.sw.y

    origin_shift_x = -Window.view.sw.x
    origin_shift_y = -Window.view.sw.y

    magfactor = com.magfactor_pixel_per_unit_length
    font_size_in_physical_unit = 0.02 * Window.draw_diag_length
    line_width_in_pixel = 2

    call turtle_epsl__initialize( magfactor,  &
                                  width_in_physical_unit,  &
                                  height_in_physical_unit,  &
                                  origin_shift_x,  &
                                  origin_shift_y,  &
                                  font_size_in_physical_unit,  &
                                  line_width_in_pixel )

    call iPrint

    Initialization_done = .true.

  contains

    subroutine iPrint
      if ( Verbose ) then
        print *, ' '
        print *, '<turtle> magfactor = ', magfactor
        print *, '<turtle> Window.view.nw.x = ', Window.view.nw.x
        print *, '<turtle> Window.view.nw.y = ', Window.view.nw.y
        print *, '<turtle> Window.view.ne.x = ', Window.view.ne.x
        print *, '<turtle> Window.view.ne.y = ', Window.view.ne.y
        print *, '<turtle> Window.view.se.x = ', Window.view.se.x
        print *, '<turtle> Window.view.se.y = ', Window.view.se.y
        print *, '<turtle> Window.view.sw.x = ', Window.view.sw.x
        print *, '<turtle> Window.view.sw.y = ', Window.view.sw.y
        print *,' <turtle> Window.draw_diag_length = ', Window.draw_diag_length
        print *,' <turtle> width_in_physical_unit = ', width_in_physical_unit
        print *,' <turtle> height_in_physical_unit = ', height_in_physical_unit
        print *,' <turtle> origin_shift_x = ', origin_shift_x
        print *,' <turtle> origin_shift_y = ', origin_shift_y
        print *,' <turtle> font_size_in_physical_unit = ', font_size_in_physical_unit
        print *,' <turtle> line_width_in_pixel = ', line_width_in_pixel
        print *, '<turtle> Window.draw.nw.x = ', Window.draw.nw.x
        print *, '<turtle> Window.draw.nw.y = ', Window.draw.nw.y
        print *, '<turtle> Window.draw.ne.x = ', Window.draw.ne.x
        print *, '<turtle> Window.draw.ne.y = ', Window.draw.ne.y
        print *, '<turtle> Window.draw.se.x = ', Window.draw.se.x
        print *, '<turtle> Window.draw.se.y = ', Window.draw.se.y
        print *, '<turtle> Window.draw.sw.x = ', Window.draw.sw.x
        print *, '<turtle> Window.draw.sw.y = ', Window.draw.sw.y
      end if
    end subroutine iPrint

  end subroutine turtle__initialize


  subroutine turtle__vector_cartesian( vector )
    type(turtle__vector2d_cartesian_t) <in> :: vector

    integer :: i, j
    type(turtle__pos_t) :: place, arrow
    real :: normalizer, factor

    if ( vector.arrow_normalization_unit > 0.0 ) then
       normalizer = vector.arrow_normalization_unit
    else
      normalizer = iCalc_amplitude()
    end if

    if(normalizer <= ALMOST_ZERO) then
       print *, "normalizer", normalizer
       return

    end if

    factor = 0.05 / normalizer

!   if ( Verbose ) &
!     print *, "<__FUNC__> normalizer = ", normalizer

    do i = 1 , vector.nx, vector.stride_for_arrow
       do j = 1 , vector.ny, vector.stride_for_arrow
          place.x = vector.xpos(i)
          place.y = vector.ypos(j)
          arrow.x = factor*vector.x(i,j)
          arrow.y = factor*vector.y(i,j)
          call turtle__arrow( place, arrow )
       end do
    end do

  contains

    function iCalc_amplitude()
      real :: iCalc_amplitude

      iCalc_amplitude = maxval( sqrt(vector.x(:,:)**2 + vector.y(:,:)**2) )
    end function iCalc_amplitude

  end subroutine turtle__vector_cartesian


  subroutine turtle__vector_polar( vector )
    type(turtle__vector2d_polar_t) <in> :: vector

    integer :: i, j
    real :: rad, tht
    type(turtle__pos_t) :: place, arrow
    real :: factor

    if ( vector.arrow_normalization_unit > 0.0 ) then
      factor = 1.0 / vector.arrow_normalization_unit
    else
      factor = 1.0 / iCalc_amplitude()
    end if

!   if ( Verbose ) &
!     print *, "<__FUNC__> norm. factor = ", factor

    do i = 1 , vector.nr, vector.stride_for_arrow
       do j = 1 , vector.nt, vector.stride_for_arrow
          rad = vector.rpos(i)
          tht = vector.tpos(j)
          place.x = rad*cos(tht)
          place.y = rad*sin(tht)
          arrow.x = factor*vector.x(i,j)
          arrow.y = factor*vector.y(i,j)
          call turtle__arrow( place, arrow )
       end do
    end do

  contains

    function iCalc_amplitude()
      real :: iCalc_amplitude
      iCalc_amplitude = maxval( sqrt(vector.x(:,:)**2 + vector.y(:,:)**2) )
    end function iCalc_amplitude

  end subroutine turtle__vector_polar


  subroutine turtle__open( device_num )
    integer <in> :: device_num
    call turtle_epsl__open( device_num )
  end subroutine turtle__open


  subroutine turtle__close
    call turtle_epsl__close
  end subroutine turtle__close


  subroutine turtle__eps_header
    if ( .not. Initialization_done ) then
      print *,'<__FUNC__> You forgot turtle_epsl__initialization.'
      return
    end if
    call turtle_epsl__header
  end subroutine turtle__eps_header


  subroutine turtle__eps_footer
    call turtle_epsl__footer
  end subroutine turtle__eps_footer


  function turtle__present_color_get_val() result(color)
    integer :: color
    color = Present_color
  end function turtle__present_color_get_val


  subroutine turtle__set_color( color )
    integer <in> :: color

    select case ( color )
      case ( TURTLE__BLACK )
         call turtle_epsl__color_set( 0.0, 0.0, 0.0 )
      case ( TURTLE__RED )
         call turtle_epsl__color_set( 1.0, 0.0, 0.0 )
      case ( TURTLE__GREEN )
         call turtle_epsl__color_set( 0.0, 1.0, 0.0 )
      case ( TURTLE__BLUE )
         call turtle_epsl__color_set( 0.0, 0.0, 1.0 )
      case ( TURTLE__PURPLE )
         call turtle_epsl__color_set( 1.0, 0.0, 1.0 )
      case default
         print *, '<__FUNC__> incorrect color. color = ', color
    end select
  end subroutine turtle__set_color

  subroutine turtle__string( pos, str, color )
    type(turtle__pos_t) <in> :: pos
    char(len=*) <in> :: str
    integer <optin> :: color
    !!>
        Write the string with the specified color.
        The default color gets back when exiting this routine.
    !!<
    if ( present( color ) )  call turtle__set_color( color )
    call turtle_epsl__string( pos.x, pos.y, str )
    if ( present( color ) )  call turtle__set_color( Present_color )
  end subroutine turtle__string


  subroutine turtle__string_bottom( str, color )
    char(len=*) <in> :: str
    integer <optin> :: color

    real :: font_size, str_length
    type(turtle__pos_t) :: pos

    pos.x = ( Window.draw.sw.x + Window.draw.se.x ) / 2
    pos.y = Window.draw.sw.y - Window.margin/2

    font_size = turtle_epsl__fontsize_get()
    str_length = len_trim( str )*font_size/sqrt(2.0)
    pos.x = pos.x - str_length / 2

    if ( present( color ) ) then
      call turtle__string( pos, str, color )
    else
      call turtle__string( pos, str )
    end if
  end subroutine turtle__string_bottom


  subroutine turtle__string_top( str, color )
    char(len=*) <in> :: str
    integer <optin> :: color

    real :: font_size, str_length
    type(turtle__pos_t) :: pos

    pos.x = ( Window.draw.nw.x + Window.draw.ne.x ) / 2
    pos.y = Window.draw.nw.y + Window.margin/2

    font_size = turtle_epsl__fontsize_get()
    str_length = len_trim(str)*font_size/sqrt(2.0)
    pos.x = pos.x - str_length / 2

    if ( present( color ) ) then
      call turtle__string( pos, str, color )
    else
      call turtle__string( pos, str )
    end if
  end subroutine turtle__string_top

end module turtle_m
