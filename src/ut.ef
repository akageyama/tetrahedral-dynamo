!!>

  History

  ut.f90
      2003.04.23: Developed by Akira Kageyama
      2003.05.21: Added ut__i2c3.
                  argument; suggested by Hiromitsu Fuchigami.
      2003.06.06: Converted ut__zeroset3d into procedure with optinal
      2003.09.05: Added ut__step.
      2003.09.09: Went back to generic interface for ut__zeroset3d.
      2003.12.13: Revised ut__message (copied from 1st mpi version.)
      2003.12.13: Added message_str_int_float_float.
                  be called from a module routine.)
      2004.03.30: Added ut__hash_i (copied from yymm-mpi: size should
      2004.03.30: Added zeroset3d1.
      2004.03.31: Removed ut__hash_i (mv to boundary.f90/register).
      2004.04.05: Changed ut__atan
      2004.04.06: Done MPI conversion.
      2006.01.16: Changed the decoration style for the subroutine.
      2006.01.18: Made ut__i2c3 a function, not a subroutine.
      2006.01.23: zeroset3d --> zeroset.
      2006.01.31: Added new function ut__i2c7.
      2006.02.01: Added ut__gets & UT__STRLEN_MAX.
      2006.08.18: Added ut__plusplus.
      2007.04.24: Added ut__assert.
      2007.05.01: Added ut__make_queue (modified register).
      2007.05.11: This is yysc-dynamo.
      2007.05.17: Divided ut__message and ut__deco_message.
      2007.05.17: Added message_str_str.
      2007.05.17: Added ut__i2c1.
      2007.06.04: Added ut__i2c4.  

  ut.f95
    2013.04.06: Added zeroset4d1_r, zeroset4d2_r, zeroset4d1_f, zeroset4d2_f.
    2013.04.11: Added ut__smooth_step.
    2013.05.18: Renamed ut.f95 --> module_ut.f95
    2013.05.18: Removed old zeroset routiens. Instead, we use elemental.
    2013.06.05: Done. This comes from old "ut.f90"
    2013.06.05: See the comment below for its (long) history.
    2013.06.06: Added message_str_double_str.
    2013.06.13: Added message_leader.

  ut.e03
    2014.12.06: DP-->DR. integer-->intg(SI)
                added the following functions that relates to ingr(DI)
                  +message_decorated_str_intd    [intd stands for integer(DI)]
                  +message_str_int_intd, etc.
    2016.06.16: Changed ut__gets private-->public by Y. Ueda.
    2017.05.15: Added comment at ut__make_queue by S. Hosoyamada.
    2017.06.16: Deleted elemental at zeroset because it is too late
                in ES3(JAMSTEC) by Y. Ueda.
    2017.07.04: Took off fancy lines around routines.  -kage
    2017.07.04: Use <in> etc. -kage
    2017.07.05: Added ut__real_to_str10 ut__int_to_str10.  -kage
    2017.07.05: Added ut__int_to_str3,4,5,6, and 8.  -kage
    2017.07.17: Added ut__positive_int_to_str9.  -kage
    2017.07.17: Added ut__positive_real_to_str9.  -kage
    2017.07.25: Added new members of ut__message.  -kage
    2017.08.04: Added ut__sleep.  -kage

  ut.ef    
    2022.07.05: Rename ut.e03 --> ut.ef
    2022.07.10: Add ut__date_and_time.  -kage

!!<



!***********************************************************************
module ut_m                                      ! Utility Routines
!***********************************************************************
  use constants_m
  implicit none
  private
  public :: & !< routines >
            ut__appear_pos,               &
            ut__assert,                   &
            ut__atan,                     &
            ut__date_and_time,            &
            ut__deco_message,             &
            ut__fatal,                    &
            ut__gets,                     &
            ut__i2c1,                     &
            ut__i2c3,                     &
            ut__i2c4,                     &
            ut__i2c7,                     &
            ut__int_to_str3,              &
            ut__int_to_str4,              &
            ut__int_to_str5,              &
            ut__int_to_str6,              &
            ut__int_to_str8,              &
            ut__int_to_str10,             &
            ut__legendren,                &
            ut__message,                  &
            ut__message_leader,           &
            ut__make_queue,               &
            ut__plusplus,                 &
            ut__positive_int_to_str9,     &
            ut__positive_real_to_str9,    &
            ut__real_to_str10,            &
            ut__sleep,                    &
            ut__smooth_step,              &
            ut__step,                     &
            ut__zeroset

!!>
  type, public :: ut__integer_triplet_t
    integer(SI) :: i, j, k
  end type
!!<


  interface ut__message
     module procedure message_str,                    &
                      message_str_double,             &
                      message_str_double_str,         &
                      message_str_int,                &
                      message_str_intd,               &
                      message_str_int_int,            &
                      message_str_int_intd,           &
                      message_str_intd_int,           &
                      message_str_intd_intd,          &
                      message_str_int_int_int,        &
                      message_str_int_int_double,     &
                      message_str_intd_int_double,    &
                      message_str_int_double,         &
                      message_str_intd_double,        &
                      message_str_int_double_double,  &
                      message_str_intd_double_double, &
                      message_str_int_float_float,    &
                      message_str_intd_float_float,   &
                      message_str_int_str,            &
                      message_str_int_str_int,        &
                      message_str_intd_str_int,       &
                      message_str_int_str_double,     &
                      message_str_intd_str_double,    &
                      message_str_logical,            &
                      message_str_logical_str,        &
                      message_str_str
  end interface

  interface ut__message_leader
     module procedure message_leader_int,             &
                      message_leader_intd,            &
                      message_leader_double,          &
                      message_leader_float,           &
                      message_leader_string
  end interface

  interface ut__deco_message
     module procedure message_decorated_str,          &
                      message_decorated_str_int,      &
                      message_decorated_str_intd
  end interface

  interface ut__real_to_str10
    module procedure real_to_str10_double,  &
                     real_to_str10_single
  end interface

  interface ut__positive_real_to_str9
    module procedure positive_real_to_str9_double,  &
                     positive_real_to_str9_single
  end interface

  interface ut__int_to_str3
    module procedure int_to_str3_with_sign_double,  &
                     int_to_str3_with_sign_single
  end interface

  interface ut__int_to_str4
    module procedure int_to_str4_with_sign_double,  &
                     int_to_str4_with_sign_single
  end interface

  interface ut__int_to_str5
    module procedure int_to_str5_with_sign_double,  &
                     int_to_str5_with_sign_single
  end interface

  interface ut__int_to_str6
    module procedure int_to_str6_with_sign_double,  &
                     int_to_str6_with_sign_single
  end interface

  interface ut__int_to_str8
    module procedure int_to_str8_with_sign_double,  &
                     int_to_str8_with_sign_single
  end interface

  interface ut__int_to_str10
    module procedure int_to_str10_with_sign_double,  &
                     int_to_str10_with_sign_single
  end interface

  interface ut__positive_int_to_str9
    module procedure positive_int_to_str9_double,  &
                     positive_int_to_str9_single
  end interface

  interface ut__zeroset
     module procedure zeroset_double01,       &
                      zeroset_double02,       &
                      zeroset_double03,       &
                      zeroset_double04,       &
                      zeroset_double_array01, &
                      zeroset_double_array02, &
                      zeroset_double_array03, &
                      zeroset_double_array04, &
                      zeroset_float01,        &
                      zeroset_float02,        &
                      zeroset_float03,        &
                      zeroset_float04,        &
                      zeroset_float_array01,  &
                      zeroset_float_array02,  &
                      zeroset_float_array03,  &
                      zeroset_float_array04
  end interface

  integer(SI) <const> :: UT__STRLEN_MAX = 5000   ! any long enough int.

contains


!!>
!    Private
!!<


  function int_to_str3_with_sign_double(i) result(str)
    integer(DI) <in> :: i
    char(len=3) :: str
    !!>
      Convert an integer into 3 characters with sign.
              i =   10 --> str="+10"
              i = -123 --> str="-XX"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 99 ) then
      str(2:3) = 'XX'
    else
      write(str(2:3),'(i2.2)') abs(i)
    end if
  end function int_to_str3_with_sign_double


  function int_to_str3_with_sign_single(i) result(str)
    integer(SI) <in> :: i
    char(len=3) :: str
    !!>
      Convert an integer into 3 characters with sign.
              i =   10 --> str="+00"
              i = -123 --> str="-NN"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 99 ) then
      str(2:3) = 'XX'
    else
      write(str(2:3),'(i2.2)') abs(i)
    end if
  end function int_to_str3_with_sign_single


  function int_to_str4_with_sign_double(i) result(str)
    integer(DI) <in> :: i
    char(len=4) :: str
    !!>
      Convert an integer into 4 characters with sign.
              i =   10 --> str="+010"
              i = -123 --> str="-123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 999 ) then
      str(2:4) = 'XXX'
    else
      write(str(2:4),'(i3.3)') abs(i)
    end if
  end function int_to_str4_with_sign_double


  function int_to_str4_with_sign_single(i) result(str)
    integer(SI) <in> :: i
    char(len=4) :: str
    !!>
      Convert an integer into 4 characters with sign.
              i =   10 --> str="+010"
              i = -123 --> str="-123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 999 ) then
      str(2:4) = 'XXX'
    else
      write(str(2:4),'(i3.3)') abs(i)
    end if
  end function int_to_str4_with_sign_single


  function int_to_str5_with_sign_double(i) result(str)
    integer(DI) <in> :: i
    char(len=5) :: str
    !!>
      Convert an integer into 5 characters with sign.
              i =   10 --> str="+0010"
              i = -123 --> str="-0123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 9999 ) then
      str(2:5) = 'XXXX'
    else
      write(str(2:5),'(i4.4)') abs(i)
    end if
  end function int_to_str5_with_sign_double


  function int_to_str5_with_sign_single(i) result(str)
    integer(SI) <in> :: i
    char(len=5) :: str
    !!>
      Convert an integer into 5 characters with sign.
              i =   10 --> str="+0010"
              i = -123 --> str="-0123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 9999 ) then
      str(2:5) = 'XXXX'
    else
      write(str(2:5),'(i4.4)') abs(i)
    end if
  end function int_to_str5_with_sign_single


  function int_to_str6_with_sign_double(i) result(str)
    integer(DI) <in> :: i
    char(len=6) :: str
    !!>
      Convert an integer into 6 characters with sign.
              i =   10 --> str="+00010"
              i = -123 --> str="-00123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 99999 ) then
      str(2:6) = 'XXXXX'
    else
      write(str(2:6),'(i5.5)') abs(i)
    end if
  end function int_to_str6_with_sign_double


  function int_to_str6_with_sign_single(i) result(str)
    integer(SI) <in> :: i
    char(len=6) :: str
    !!>
      Convert an integer into 6 characters with sign.
              i =   10 --> str="+00010"
              i = -123 --> str="-00123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 99999 ) then
      str(2:6) = 'XXXXX'
    else
      write(str(2:6),'(i5.5)') abs(i)
    end if
  end function int_to_str6_with_sign_single


  function int_to_str8_with_sign_double(i) result(str)
    integer(DI) <in> :: i
    char(len=8) :: str
    !!>
      Convert an integer into 8 characters with sign.
              i =   10 --> str="+0000010"
              i = -123 --> str="-0000123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 9999999 ) then
      str(2:8) = 'XXXXXXX'
    else
      write(str(2:8),'(i7.7)') abs(i)
    end if
  end function int_to_str8_with_sign_double


  function int_to_str8_with_sign_single(i) result(str)
    integer(SI) <in> :: i
    char(len=8) :: str
    !!>
      Convert an integer into 8 characters with sign.
              i =   10 --> str="+0000010"
              i = -123 --> str="-0000123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 9999999 ) then
      str(2:8) = 'XXXXXXX'
    else
      write(str(2:8),'(i7.7)') abs(i)
    end if
  end function int_to_str8_with_sign_single


  function int_to_str10_with_sign_double(i) result(str)
    integer(DI) <in> :: i
    char(len=10) :: str
    !!>
      Convert an integer into 10 characters with sign.
              i =   10 --> str="+000000010"
              i = -123 --> str="-000000123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 999999999 ) then
      str(2:10) = 'XXXXXXXXX'
    else
      write(str(2:10),'(i9.9)') abs(i)
    end if
  end function int_to_str10_with_sign_double


  function int_to_str10_with_sign_single(i) result(str)
    integer(SI) <in> :: i
    char(len=10) :: str
    !!>
      Convert an integer into 10 characters with sign.
              i =   10 --> str="+000000010"
              i = -123 --> str="-000000123"
    !!<
    if ( i < 0 ) then
      str(1:1) = '-'
    else
      str(1:1) = '+'
    end if
    if ( abs(i) > 999999999 ) then
      str(2:10) = 'XXXXXXXXX'
    else
      write(str(2:10),'(i9.9)') abs(i)
    end if
  end function int_to_str10_with_sign_single


  subroutine message_decorated_str(mark,string)
    char(len=1) <in> :: mark
    char(len=*) <in> :: string
      !!>
        Usage:
           call message_decorated_str('#',"This is a test.")
        Output:     ###################
                    # This is a test. #
                    ###################
      !!<
    integer(SI) :: len

    len = len_trim(string) + 4

    print *, repeat(mark,len)
    print *, mark//' '//trim(string)//' '//mark
    print *, repeat(mark,len)
  end subroutine message_decorated_str


  subroutine message_decorated_str_int(mark,string,int)
    char(len=1) <in> :: mark
    char(len=*) <in> :: string
    integer(SI) <in> :: int
      !!>
        Usage:
           call mess...('#','This is message at nloop = ', nloop)
      !!<
    char(len=200) :: string_int

    write(string_int,'(a,i8)') string, int
    call message_decorated_str(mark, string_int)
  end subroutine message_decorated_str_int


  subroutine message_decorated_str_intd(mark,string,int)
    char(len=1) <in> :: mark
    char(len=*) <in> :: string
    integer(DI) <in> :: int
     !!>
       Usage:
          call mess...('#','This is message at nloop = ', nloop)
     !!<
    char(len=200) :: string_int
    write(string_int,'(a,i14)') string, int
    call message_decorated_str(mark, string_int)
  end subroutine message_decorated_str_intd


  subroutine message_leader_int(string,i01)
    char(len=*) <in> :: string
    integer(SI) <in> :: i01

    integer(SI) <const> :: TOTAL_LENGTH = 60

    char(len=12)           :: string_for_i01
    char(len=TOTAL_LENGTH) :: line

    line = repeat('.', TOTAL_LENGTH)

    write(string_for_i01, '(a1,i0)') ' ', i01 ! put a space in front of i01
    line(1:len_trim(string)) = trim(string)
    line(TOTAL_LENGTH-len_trim(string_for_i01):TOTAL_LENGTH)    &
       = trim(string_for_i01)
    print *, line
  end subroutine message_leader_int


  subroutine message_leader_intd(string,i01)
    char(len=*) <in> :: string
    integer(DI) <in> :: i01

    integer(SI) <const>    :: TOTAL_LENGTH = 60
    char(len=20)           :: string_for_i01
    char(len=TOTAL_LENGTH) :: line

    line = repeat('.', TOTAL_LENGTH)

    write(string_for_i01, '(a1,i0)') ' ', i01 ! put a space in front of i01
    line(1:len_trim(string)) = trim(string)
    line(TOTAL_LENGTH-len_trim(string_for_i01):TOTAL_LENGTH)    &
       = trim(string_for_i01)
    print *, line
  end subroutine message_leader_intd


  subroutine message_leader_double(string, d01)
    char(len=*) <in> :: string
    real(DR)    <in> :: d01

    integer(SI) <const>    :: TOTAL_LENGTH = 60
    char(len=22)           :: string_for_value
    char(len=TOTAL_LENGTH) :: line

    line = repeat('.',TOTAL_LENGTH)

    write(string_for_value,'(1pe22.15)') d01
    line(1:len_trim(string)) = trim(string)
    line(TOTAL_LENGTH-22:TOTAL_LENGTH) = string_for_value
    print *, line
  end subroutine message_leader_double


  subroutine message_leader_float(string,f01)
    char(len=*) <in> :: string
    real(SR)    <in> :: f01

    integer(SI) <const> :: TOTAL_LENGTH = 60
    char(len=12) :: string_for_value
    char(len=TOTAL_LENGTH) :: line

    line = repeat('.',TOTAL_LENGTH)

    write(string_for_value, '(1pe12.5)') f01
    line(1:len_trim(string)) = trim(string)
    line(TOTAL_LENGTH-12:TOTAL_LENGTH) = string_for_value
    print *, line
  end subroutine message_leader_float


  subroutine message_leader_string(string,s01)
    char(len=*) <in> :: string
    char(len=*) <in> :: s01

    integer(SI) <const> :: TOTAL_LENGTH = 60
    char(len=len_trim(s01)+1) :: s01_
    char(len=TOTAL_LENGTH) :: line
    line = repeat('.', TOTAL_LENGTH)
    s01_ = ' '//s01  ! put a blank in front of s01.

    line(1:len_trim(string)) = trim(string)
    line(TOTAL_LENGTH-len_trim(s01_):TOTAL_LENGTH) = s01_
    print *, line
  end subroutine message_leader_string


  subroutine message_str(string)
    char(len=*) <in> :: string

    print *, string
  end subroutine message_str


  subroutine message_str_double(string, double)
    char(len=*) <in> :: string
    real(DR)    <in> :: double

    print *, string, double
  end subroutine message_str_double


  subroutine message_str_double_str(str01, double, str02)
    char(len=*) <in> :: str01, str02
    real(DR)    <in> :: double

    print *, str01, double, str02
  end subroutine message_str_double_str



  subroutine message_str_str(string01, string02)
    char(len=*) <in> :: string01
    char(len=*) <in> :: string02

    print *, string01, string02
  end subroutine message_str_str


  subroutine message_str_int(string, int)
    char(len=*) <in> :: string
    integer(SI)    <in> :: int

    print *, string, int
  end subroutine message_str_int


  subroutine message_str_intd(string, int)
    char(len=*) <in> :: string
    integer(DI)    <in> :: int

    print *, string, int
  end subroutine message_str_intd


  subroutine message_str_int_int(string, i1, i2)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1, i2

    print *, string, i1, i2
  end subroutine message_str_int_int


  subroutine message_str_int_intd(string, i1, i2)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1
    integer(DI) <in> :: i2

    print *, string, i1, i2
  end subroutine message_str_int_intd


  subroutine message_str_intd_int(string, i1, i2)
    char(len=*) <in> :: string
    integer(DI) <in> :: i1
    integer(SI) <in> :: i2

    print *, string, i1, i2
  end subroutine message_str_intd_int


  subroutine message_str_intd_intd(string, i1, i2)
    char(len=*) <in> :: string
    integer(DI) <in> :: i1, i2

    print *, string, i1, i2
  end subroutine message_str_intd_intd


  subroutine message_str_int_int_int(string, i1, i2, i3)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1, i2, i3

    print *, string, i1, i2, i3
  end subroutine message_str_int_int_int


  subroutine message_str_int_int_double(string, i1, i2, d1)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1, i2
    real(DR)    <in> :: d1

    print *, string, i1, i2, d1
  end subroutine message_str_int_int_double


  subroutine message_str_intd_int_double(string, i1, i2, d1)
    char(len=*) <in> :: string
    integer(DI) <in> :: i1
    integer(SI) <in> :: i2
    real(DR)    <in> :: d1

    print *, string, i1, i2, d1
  end subroutine message_str_intd_int_double



  subroutine message_str_int_double(string, i1, d1)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1
    real(DR)    <in> :: d1

    print *, string, i1, d1
  end subroutine message_str_int_double


  subroutine message_str_intd_double(string, i1, d1)
    char(len=*) <in> :: string
    integer(DI)    <in> :: i1
    real(DR)    <in> :: d1

    print *, string, i1, d1
  end subroutine message_str_intd_double


  subroutine message_str_int_double_double(string, i1, d1, d2)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1
    real(DR)    <in> :: d1, d2

    print *, string, i1, d1, d2
  end subroutine message_str_int_double_double


  subroutine message_str_intd_double_double(string, i1, d1, d2)
    char(len=*) <in> :: string
    integer(DI) <in> :: i1
    real(DR)    <in> :: d1, d2

    print *, string, i1, d1, d2
  end subroutine message_str_intd_double_double


  subroutine message_str_int_float_float(string, i1, f1, f2)
    char(len=*) <in> :: string
    integer(SI) <in> :: i1
    real(SR)    <in> :: f1, f2
    print *, string, i1, f1, f2
  end subroutine message_str_int_float_float


  subroutine message_str_intd_float_float(string, i1, f1, f2)
    char(len=*) <in> :: string
    integer(DI) <in> :: i1
    real(SR)    <in> :: f1, f2
    print *, string, i1, f1, f2
  end subroutine message_str_intd_float_float


  subroutine message_str_int_str(str1, i1, str2)
    char(len=*) <in> :: str1, str2
    integer(SI) <in> :: i1
    print *, str1, i1, str2
  end subroutine message_str_int_str


  subroutine message_str_int_str_int(str1, i1, str2, i2)
    char(len=*) <in> :: str1, str2
    integer(SI) <in> :: i1, i2
    print *, str1, i1, str2, i2
  end subroutine message_str_int_str_int


  subroutine message_str_intd_str_int(str1, i1, str2, i2)
    char(len=*) <in> :: str1, str2
    integer(DI) <in> :: i1
    integer(SI) <in> :: i2

    print *, str1, i1, str2, i2
  end subroutine message_str_intd_str_int


  subroutine message_str_int_str_double(str1, i1, str2, d1)
    char(len=*) <in> :: str1, str2
    integer(SI) <in> :: i1
    real(DR)    <in> :: d1
    print *, str1, i1, str2, d1
  end subroutine message_str_int_str_double


  subroutine message_str_intd_str_double(str1, i1, str2, d1)
    char(len=*) <in> :: str1, str2
    integer(DI) <in> :: i1
    real(DR)    <in> :: d1

    print *, str1, i1, str2, d1
  end subroutine message_str_intd_str_double

  subroutine message_str_logical(str1, logical)
    char(len=*) <in> :: str1
    logical     <in> :: logical
    print *, str1, logical
  end subroutine message_str_logical

  subroutine message_str_logical_str(str1, logical, str2)
    char(len=*) <in> :: str1, str2
    logical     <in> :: logical
    print *, str1, logical, str2
  end subroutine message_str_logical_str


  function positive_int_to_str9_double(i) result(str)
    integer(DI) <in> :: i
    char(len=9) :: str

    !!>
      Convert a positive integer into 9 characters without '+' symbol.
              i =  123 --> str="000000123"
    !!<
    char(len=10) :: str10
    if ( i < 0 ) then
      str = '---------'
    else if ( abs(i) > 999999999 ) then
      str = 'XXXXXXXXX'
    else
      str10 = ut__int_to_str10(i)
      str = str10(2:10)
    end if
  end function positive_int_to_str9_double


  function positive_int_to_str9_single(i) result(str)
    integer(SI) <in> :: i
    char(len=9) :: str

    !!>
      Convert a positive integer into 9 characters without '+' symbol.
              i =  123 --> str="000000123"
    !!<
    char(len=10) :: str10
    if ( i < 0 ) then
      str = '---------'
    else if ( abs(i) > 999999999 ) then
      str = 'XXXXXXXXX'
    else
      str10 = ut__int_to_str10(i)
      str = str10(2:10)
    end if
  end function positive_int_to_str9_single


  function positive_real_to_str9_double(d) result(str)
    real(DR) <in> :: d
    char(len=9) :: str
    !!>
      double to character string, e.g., d=0.123456 ==> str="1.234E-01"
    !!<
    char(len=10) :: str10
    if ( d < 0.0_DR ) then
      str = '---------'
    else
      str10 = ut__real_to_str10(d)
      str = str10(2:10)
    end if
  end function positive_real_to_str9_double


  function positive_real_to_str9_single(f) result(str)
    real(SR) <in> :: f
    char(len=9) :: str
    !!>
      double to character string, e.g., f=0.123456 ==> str="1.234E-01"
    !!<
    char(len=10) :: str10
    if ( f < 0.0_SR ) then
      str = '---------'
    else
      str10 = ut__real_to_str10(f)
      str = str10(2:10)
    end if
  end function positive_real_to_str9_single


  function real_to_str10_double(d) result(str)
    real(DR) <in> :: d
    char(len=10) :: str
    !!>
      double to character string, e.g., d=0.123456 ==> str="+1.235E1"
    !!<
    write(str,'(1pe10.3)') d
    if(str(1:1)==' ') str(1:1)='+'
  end function real_to_str10_double


  function real_to_str10_single(f) result(str)
    real(SR) <in> :: f
    char(len=10) :: str
    !!>
      double to character string, e.g., f=0.123456 ==> str="+1.235E1"
    !!<
    write(str,'(1pe10.3)') f
    if(str(1:1)==' ') str(1:1)='+'
  end function real_to_str10_single


  subroutine zeroset_double01(d01)
    real(DR) <out> :: d01
    d01 = 0.0_DR
  end subroutine zeroset_double01


  subroutine zeroset_double02(d01, d02)
    real(DR) <out> :: d01, d02
    d01 = 0.0_DR
    d02 = 0.0_DR
  end subroutine zeroset_double02


  subroutine zeroset_double03(d01, d02, d03)
    real(DR) <out> :: d01, d02, d03
    d01 = 0.0_DR
    d02 = 0.0_DR
    d03 = 0.0_DR
  end subroutine zeroset_double03


  subroutine zeroset_double04(d01, d02, d03, d04)
    real(DR) <out> :: d01, d02, d03, d04
    d01 = 0.0_DR
    d02 = 0.0_DR
    d03 = 0.0_DR
    d04 = 0.0_DR
  end subroutine zeroset_double04


  subroutine zeroset_double_array01(d01)
    real(DR) <out> :: d01(:,:,:)
    d01(:,:,:) = 0.0_DR
  end subroutine zeroset_double_array01


  subroutine zeroset_double_array02(d01, d02)
    real(DR) <out> :: d01(:,:,:),  &
                      d02(:,:,:)
    d01(:,:,:) = 0.0_DR
    d02(:,:,:) = 0.0_DR
  end subroutine zeroset_double_array02



  subroutine zeroset_double_array03(d01, d02, d03)
    real(DR) <out> :: d01(:,:,:),  &
                      d02(:,:,:),  &
                      d03(:,:,:)
    d01(:,:,:) = 0.0_DR
    d02(:,:,:) = 0.0_DR
    d03(:,:,:) = 0.0_DR
  end subroutine zeroset_double_array03


  subroutine zeroset_double_array04(d01, d02, d03, d04)
    real(DR) <out> :: d01(:,:,:),  &
                      d02(:,:,:),  &
                      d03(:,:,:),  &
                      d04(:,:,:)
    d01(:,:,:) = 0.0_DR
    d02(:,:,:) = 0.0_DR
    d03(:,:,:) = 0.0_DR
    d04(:,:,:) = 0.0_DR
  end subroutine zeroset_double_array04


  subroutine zeroset_float01(f01)
    real(SR) <out> :: f01
    f01 = 0.0_SR
  end subroutine zeroset_float01


  subroutine zeroset_float02(f01, f02)
    real(SR) <out> :: f01, f02
    f01 = 0.0_SR
    f02 = 0.0_SR
  end subroutine zeroset_float02


  subroutine zeroset_float03(f01, f02, f03)
    real(SR) <out> :: f01, f02, f03
    f01 = 0.0_SR
    f02 = 0.0_SR
    f03 = 0.0_SR
  end subroutine zeroset_float03


  subroutine zeroset_float04(f01, f02, f03, f04)
    real(SR) <out> :: f01, f02, f03, f04
    f01 = 0.0_SR
    f02 = 0.0_SR
    f03 = 0.0_SR
    f04 = 0.0_SR
  end subroutine zeroset_float04


  subroutine zeroset_float_array01(f01)
    real(SR) <out> :: f01(:,:,:)
    f01(:,:,:) = 0.0_SR
  end subroutine zeroset_float_array01


  subroutine zeroset_float_array02(f01, f02)
    real(SR) <out> :: f01(:,:,:),  &
                      f02(:,:,:)
    f01(:,:,:) = 0.0_SR
    f02(:,:,:) = 0.0_SR
  end subroutine zeroset_float_array02


  subroutine zeroset_float_array03(f01, f02, f03)
    real(SR) <out> :: f01(:,:,:),  &
                      f02(:,:,:),  &
                      f03(:,:,:)
    f01(:,:,:) = 0.0_SR
    f02(:,:,:) = 0.0_SR
    f03(:,:,:) = 0.0_SR
  end subroutine zeroset_float_array03


  subroutine zeroset_float_array04(f01, f02, f03, f04)
    real(SR) <out> :: f01(:,:,:),  &
                      f02(:,:,:),  &
                      f03(:,:,:),  &
                      f04(:,:,:)
    f01(:,:,:) = 0.0_SR
    f02(:,:,:) = 0.0_SR
    f03(:,:,:) = 0.0_SR
    f04(:,:,:) = 0.0_SR
  end subroutine zeroset_float_array04


! private
!=========
! public


  function ut__appear_pos(tag, tag_list) result(nth)
    integer(SI) <in> :: tag
    integer(SI) <in> :: tag_list(:)
    integer(SI) :: nth
      !!>
        To find the integer nth that satisfies tag_list(nth) = tag.
        Returns NIL if it could not find the member.
      !!<
    integer(SI) :: i

    do i = 1 , size(tag_list,dim=1)
       if ( tag_list(i)==tag ) then
          nth = i
          return
       end if
    end do
    nth = NIL
  end function ut__appear_pos


  subroutine ut__assert(must_be_true, message)
    logical     <in> :: must_be_true
    char(len=*) <in> :: message

    if ( .not. must_be_true ) then
       call ut__fatal(message)
    end if
  end subroutine ut__assert


  function ut__atan(y,x)
    real(DR) <in> :: y, x
    real(DR) :: ut__atan

      !!>
        170628: Changed the input type from SR to DR.
                 I do not know why it was SR. ---kage.
      !!<

    ut__atan = atan2(y,x)

      !!>
        2004.04.05: redefined phi span: from -3pi/4 to 3pi/4.
             if( ut__atan<0.0_DR ) ut__atan = ut__atan + TWOPI
      !!<
  end function ut__atan


  subroutine ut__fatal(last_will)
    char(len=*) <in> :: last_will
      !!>
        Print a fatal message and stop.
      !!<
    call ut__deco_message('!',last_will)
    print *, 'Program stopped by ut__fatal.'
    stop
  end subroutine ut__fatal


  function ut__gets(file_unit, end_of_file)
    integer(SI) <in> :: file_unit
    logical <out> :: end_of_file
    char(len=UT__STRLEN_MAX) :: ut__gets

    !!>
      f90 version of gets (get-string). To read a line of text or
      string from the input file specified by the unit number of file_unit.

      Developed by Akira kageyama on 2006.02.01.

      Usage:
         e.g., print *, trim(ut__gets(FILE_STANDARD_IN))
    !!<

    char(len=7) :: form   ! when UT__STRLEN_MAX=200, form = "(a0200)"
                                              ! len=7 comes from "1234567".
    end_of_file = .false.
    if ( UT__STRLEN_MAX >= 10000 ) then
       ! You should do; (i) make len=8 of form; (ii) (a2,i5.5,a1), below.
       call ut__fatal("<ut__text_line> UT__STRLEN_MAX too large."        &
                    //" Increase len (=7, now) of form.")
    end if
    write(form,'(a2,i4.4,a1)') "(a",UT__STRLEN_MAX,")"
    read(file_unit,form,end=1000) ut__gets
    return
    1000 end_of_file = .true.
  end function ut__gets


  function ut__i2c1(i)
    integer(SI) <in> :: i
    char(len=1) :: ut__i2c1

    ! Convert an integer into a character.

    if ( i < 0 ) then
       ut__i2c1 = 'N'
    else if ( i > 9 ) then
       ut__i2c1 = 'X'
    else
       write(ut__i2c1,'(i1.1)') i
    end if
  end function ut__i2c1


  function ut__i2c3(i)
    integer(SI) <in> :: i
    char(len=3) :: ut__i2c3

    ! Convert an integer into 3 characters.
    !             e.g., i=10 --> str3="010"

    if ( i < 0 ) then
       ut__i2c3 = 'NNN'
    else if ( i > 999 ) then
       ut__i2c3 = 'XXX'
    else
       write(ut__i2c3,'(i3.3)') i
    end if
  end function ut__i2c3


  function ut__i2c4(i)
    integer(SI) <in> :: i
    char(len=4) :: ut__i2c4

    ! Convert an integer into 4 characters.
    !             e.g., i=10 --> str4="0010"

    if ( i < 0 ) then
       ut__i2c4 = 'NNNN'
    else if ( i > 9999 ) then
       ut__i2c4 = 'XXXX'
    else
       write(ut__i2c4,'(i4.4)') i
    end if
  end function ut__i2c4


  function ut__i2c7(i)
    integer(SI) <in> :: i
    char(len=7) :: ut__i2c7

    ! Convert an integer into 7 characters.
    !             e.g., i=10 --> str7="0000010"

    if ( i < 0 ) then
       ut__i2c7 = 'NNNNNNN'
    else if ( i > 9999999 ) then
       ut__i2c7 = 'XXXXXXX'
    else
       write(ut__i2c7,'(i7.7)') i
    end if
  end function ut__i2c7


  subroutine ut__legendren(l,m,x,y)
    integer(SI) <in>  :: l, m
    real(DR) <in>  :: x
    real(DR) <out> :: y

    !!>
      - "legendren" stands for Legendr-normalized.

      - Calculates the normalized associated Legendre function
                                               $C_{lm}{P_l}^m$.
      - Reference: Numerical Recipe in C, Chapter 6 p254

            0 <= m <= l,  -1. <= x <= 1.
    !!<

    real(DR) :: pmm, fact, fact1, fact2, pmmp1, somx2
    real(DR) :: pll = -huge(1.0_DR)  ! dummy initialization to shut
    integer(SI) :: ll, i                ! the compiler warning up.

    pmm = 1.0_DR

    if (m>0) then
       somx2 = sqrt((1.0_DR-x)*(1.0_DR+x))
       do i = 1 , m
          ! Note the sign before the fact. This definition follows "Recipe".
          fact = sqrt(real(2*i-1,DR)/real(2*i,DR))
          pmm = -fact * somx2 * pmm
       end do
       pmm = pmm * sqrt(real(2*m+1,DR)/(4*PI))
    else
       pmm = sqrt(1.0_DR/(4*PI))
    end if

    if (l==m) then
       y = pmm
    else
       pmmp1 = x * sqrt(real(2*m+3,DR)) * pmm
       if (l==m+1) then
          y = pmmp1
       else
          do ll = m+2 , l
             fact1 = sqrt( (real(2*ll+1,DR)*real(ll-m,DR)) &
                         / (real(2*ll-1,DR)*real(ll+m,DR)) &
                         )
             fact2 = sqrt( (real(2*ll+1,DR)*real(ll-m,DR)*real(ll-m-1,DR)) &
                         / (real(2*ll-3,DR)*real(ll+m,DR)*real(ll+m-1,DR)) &
                         )
             pll = ( x*real(2*ll-1,DR)*fact1*pmmp1  &
                     - real(ll+m-1,DR)*fact2*pmm ) / real(ll-m,DR)
             pmm = pmmp1
             pmmp1 = pll
          end do
          y = pll
       endif
    endif
  end subroutine ut__legendren


  subroutine ut__make_queue(tag,                                &
                            tag_list,                           &
                            tag_counts,                         &
                            ntags,                              &
                            nth)
    integer(SI) <in>  :: tag
    integer(SI) <io>  :: tag_list(:)
    integer(SI) <io>  :: tag_counts(:)
    integer(SI) <out> :: ntags
    integer(SI) <out> :: nth

    !!>

      Basic relation:    tag_list(nth) = tag

       The initial condition of tag_list and tag_counts are
       supposed to be:

          tag_list(1) = NIL,     tag_counts(1) = 0
          tag_list(2) = NIL,     tag_counts(2) = 0
          tag_list(3) = NIL,     tag_counts(3) = 0
              .                       .
              .                       .
              .                       .

       When you call as follows
          call ut__make_queue(30,tag_list,tag_counts,nth)  !=>  nth = 1
          call ut__make_queue(21,tag_list,tag_counts,nth)  !=>  nth = 2
          call ut__make_queue( 5,tag_list,tag_counts,nth)  !=>  nth = 3
          call ut__make_queue(12,tag_list,tag_counts,nth)  !=>  nth = 4
          call ut__make_queue(30,tag_list,tag_counts,nth)  !=>  nth = 1
          call ut__make_queue( 5,tag_list,tag_counts,nth)  !=>  nth = 3
          call ut__make_queue( 5,tag_list,tag_counts,nth)  !=>  nth = 3
          call ut__make_queue(18,tag_list,tag_counts,nth)  !=>  nth = 5

                        ||            c o n t e t s
             l i s t    ||----------------------------------------
                        ||     1     |     2     |     3     | ...
         ---------------++----------------------------------------
                1       ||    30     |    30     |           |
         ---------------------------------------------------------
                2       ||    21     |           |           |
         ---------------------------------------------------------
                3       ||     5     |     5     |     5     |
         ---------------------------------------------------------
                4       ||    12     |           |           |
         ---------------------------------------------------------
                5       ||    18     |           |           |
         ---------------------------------------------------------
                :       ||           |           |           |

         tag_list must be equal tag_contents


       The resulting two arrays tag_list(:) and tag_counts(:) are

          tag_list(1) = 30         tag_counts(1) = 2
          tag_list(2) = 21         tag_counts(2) = 1
          tag_list(3) = 5          tag_counts(3) = 3
          tag_list(4) = 12         tag_counts(4) = 1
          tag_list(5) = 18         tag_counts(5) = 1
          tag_list(6) = NIL        tag_counts(6) = 0
          tag_list(7) = NIL        tag_counts(7) = 0
          tag_list(8) = NIL        tag_counts(8) = 0

       and ntags = 5.

    !!<

    integer(SI) :: i

    call ut__assert(size(tag_list,dim=1)==size(tag_counts,dim=1),  &
                   '<ut__make_queue> size inconsistent.')

    nth = 0
    ntags = 0

    ! Count how many tags already registered.
    do i = 1 , size(tag_list,dim=1)
       if ( tag_list(i)==NIL ) exit
       ntags = i
    end do

    ! If the input "tag" is previously registered,
    ! the following do loop works.
    do i = 1 , ntags
       if ( tag_list(i)==tag ) then
          nth = i
          tag_counts(i) = tag_counts(i) + 1
          return
       end if
    end do

    ! This "tag" is a new one.
    ntags = ntags + 1
    if (ntags > size(tag_list,dim=1)) &
         call ut__fatal('<ut__make_queue> Too many tags.')
                        ! The remedy is simple. Enlarge tag_list size.

    nth = ntags
    tag_list(ntags) = tag
    tag_counts(ntags) = tag_counts(ntags) + 1
  end subroutine ut__make_queue

  
  function ut__date_and_time() result(string)
    char(len=8)  :: date   ! e.g., "20220709"
    char(len=10) :: time   ! "HHMMSS.sss"
    char(len=4)  :: year
    char(len=2)  :: month, day, hour, minute, second
    char(len=10) :: year_month_day     ! e.g., "2022.07.09"
    char(len=8)  :: hour_minute_second ! e.g., "16:56:00"
    char(len=19) :: string ! e.g., "2022.07.09/16:56:00"

    call date_and_time(date, time)

    year   = date(1:4)
    month  = date(5:6)
    day    = date(7:8)
    hour   = time(1:2)
    minute = time(3:4)
    second = time(5:6)

    year_month_day     = year // '.' // month // '.' // day
    hour_minute_second = hour // ':' // minute // ':' // second

    string = year_month_day // '/' // hour_minute_second
  end function ut__date_and_time


  subroutine ut__sleep(second)
    real(SR) <in> :: second
    !!>
      Sleeps for roughly "second" seconds. Not very exact.
         Sample:
         ----
         !  program test
         !  use const_m
         !  use ut_m
         !  implicit none
         !    char(len=10) :: time
         !    call date_and_time(time=time)
         !    print *, time
         !    call ut__sleep(1.2)
         !    call date_and_time(time=time)
         !    print *, time
         !  end program
         ----
    !!<

    char(len=10) :: time_stt, time_now
    real(DR) :: double_time_stt, double_time_now
    real(DR) :: dt

    call date_and_time(time=time_stt)
    read(time_stt,'(f12.3)') double_time_stt
    do
       call date_and_time(time=time_now)
       call iTime_killer
       read(time_now,'(f12.3)') double_time_now
       if ( double_time_now < double_time_stt ) then ! passed midnight.
         double_time_now = double_time_now + 240000.000_DR
       end if
       dt = double_time_now - double_time_stt
       if ( real(dt,SR) >= second ) exit
    end do

  contains

    subroutine iTime_killer
      integer :: i
      real(DR) :: x
      x = 1.0_DR
      do i = 1 , 10**4
        x = sin(x)
      end do
    end subroutine

  end subroutine


  function ut__smooth_step(x,width)
    real(DR) <in> :: x
    real(DR) <in> :: width
    real(DR) :: ut__smooth_step

    !!>
      A "smooth" step function

                          |
                       1.0|      +++++++++
                          |   +
                          | +
                          |+
                          +
                         +|
                        + |
                      +   |
           +++++++++------+-0.0--------------> x
                    |     |     |
                    |<--width-->|
                          |
    !!<

    real(DR) :: width_half_inv

    width_half_inv = 2.0_DR / width  ! = 1/(width/2)

    ut__smooth_step = 0.5_DR + 0.5_DR * tanh(x*width_half_inv)
  end function ut__smooth_step


  function ut__step(x)
    real(DR) <in> :: x
    real(DR) :: ut__step

    !!>
      Step function with special care for the case x=0.

                      ***********  1.0
                      *
                      X 0.5
                      *
      0.0  ***********|-------------> x
                      0
    !!<

    if (x > 0.0_DR)       then
       ut__step = 1.0_DR
    else if (x < 0.0_DR) then
       ut__step = 0.0_DR
    else      !  x is exactly 0.0_DR
       ut__step = 0.5_DR
    end if
  end function ut__step


  subroutine ut__plusplus(i)
    integer(SI) <io> :: i
    ! Just i++.
    i = i + 1
  end subroutine ut__plusplus

end module ut_m

